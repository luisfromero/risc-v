import json
import os

# --- Helpers ---
def bool_to_cpp(b):
    """Converts Python bool to C++ bool string."""
    return "true" if b else "false"

def bool_to_dart(b):
    """Converts Python bool to Dart bool string."""
    return "true" if b else "false"

def calculate_control_word(instruction, layout):
    """Calculates the 16-bit control word for a given instruction."""
    word = 0
    # The names of the fields in the layout that constitute the control word
    control_fields = layout['fields'].keys()
    
    for name in control_fields:
        details = layout['fields'][name]
        pos = details['position']
        width = details['width']
        
        # Get value from the instruction dictionary
        val = instruction.get(name)
        
        if val is None:
            continue

        # Handle boolean values
        if isinstance(val, bool):
            val = 1 if val else 0
        
        # Handle the -1 case for "don't care" / all-ones
        if val == -1:
            val = (1 << width) - 1
            
        masked_val = val & ((1 << width) - 1)
        word |= (masked_val << pos)
        
    return word

# --- Generators ---
def generate_cpp_header(instructions, layout, path):
    """Generates the C++ header file with the control table data."""
    # Helper to format uint8_t values for C++, avoiding narrowing conversion warnings for -1.
    def format_uint8(val):
        if val == -1:
            return "0xFF"
        return f'static_cast<uint8_t>({val})'

    with open(path, 'w', encoding='utf-8') as f:
        f.write("// Generated file. DO NOT EDIT.\n")
        f.write("// This file is automatically generated by the 'generate_control_table.py' script.\n")
        f.write("// Any changes made to this file will be overwritten.\n\n")
        f.write('#pragma once\n\n')
        f.write('#include "ControlUnit.h" // Defines InstructionInfo\n')
        f.write('#include <cstdint>\n')
        f.write('#include <vector>\n\n')
        f.write("namespace riscv_sim {\n\n")

        # --- Control Word Layout ---
        f.write("/*\n * Control Word Layout\n")
        f.write(" * ---------------------\n")
        f.write(f" * {layout['comment']}\n")
        f.write(" */\n")
        f.write("namespace ControlWord {\n")
        for name, details in layout['fields'].items():
            f.write(f"    // {details['description']}\n")
            f.write(f"    constexpr int {name}_pos = {details['position']};\n")
            f.write(f"    constexpr int {name}_width = {details['width']};\n")
        f.write("} // namespace ControlWord\n\n")

        # --- Instruction Table ---
        f.write("// Fields: instr, PCsrc, BRwr, ALUsrc, ALUctr, MemWr, ResSrc, ImmSrc, mask, value, type, cycles, control_word\n")
        f.write("static const InstructionInfo control_table_data[] = {\n")
        for item in instructions:
            alu_ctr_val = format_uint8(item["ALUctr"])
            res_src_val = format_uint8(item["ResSrc"])
            imm_src_val = format_uint8(item["ImmSrc"])
            pc_src_val = format_uint8(item["PCsrc"])
            alu_src_val = format_uint8(item["ALUsrc"])
            line = (
                f'    {{"{item["instr"]}", {pc_src_val}, {bool_to_cpp(item["BRwr"])}, '
                f'{alu_src_val}, {alu_ctr_val}, {bool_to_cpp(item["MemWr"])}, '
                f'{res_src_val}, {imm_src_val}, 0x{item["mask"]:X}, '
                f'0x{item["value"]:X}, \'{item["type"]}\', {item["cycles"]}, 0x{item["control_word"]:04X}}},\n'
            )
            f.write(line)
        f.write("};\n\n")
        f.write("} // namespace riscv_sim\n")
    print(f"Generated C++ header: {path}")

def generate_dart_file(instructions, layout, path):
    """Generates the Dart file with the control table data."""
    # Create a NOP instruction to use for default values in the empty constructor.
    # A NOP is equivalent to 'addi x0, x0, 0'.
    nop_instr_data = {
        "instr": "nop", "PCsrc": 0, "BRwr": True, "ALUsrc": 1, "ALUctr": 0,
        "MemWr": False, "ResSrc": 0, "ImmSrc": 0, "mask": 0x707F, "value": 0x13,
        "type": 'I', "cycles": 1
    }
    # We need to calculate its control word just like any other instruction.
    nop_instr_data['control_word'] = calculate_control_word(nop_instr_data, layout)


    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, 'w', encoding='utf-8') as f:
        f.write("// Generated file. DO NOT EDIT.\n")
        f.write("// This file is automatically generated by the 'generate_control_table.py' script.\n")
        f.write("// Any changes made to this file will be overwritten.\n\n")

        # --- Control Word Layout ---
        f.write("class ControlWordField {\n")
        f.write("  final String name;\n")
        f.write("  final int position;\n")
        f.write("  final int width;\n")
        f.write("  final String description;\n\n")
        f.write("  const ControlWordField({\n")
        f.write("    required this.name, required this.position, required this.width, required this.description,\n")
        f.write("  });\n}\n\n")
        f.write("const Map<String, ControlWordField> controlWordLayout = {\n")
        for name, details in layout['fields'].items():
            f.write(f'  "{name}": const ControlWordField(\n')
            f.write(f'    name: "{name}",\n')
            f.write(f'    position: {details["position"]},\n')
            f.write(f'    width: {details["width"]},\n')
            f.write(f'    description: "{details["description"]}",\n')
            f.write("  ),\n")
        f.write("};\n\n")

        # --- Instruction Table ---
        f.write("class InstructionInfo {\n")
        f.write("  final String instr;\n")
        f.write("  final int pcSrc;\n")
        f.write("  final bool brWr;\n")
        f.write("  final int aluSrc;\n")
        f.write("  final int aluCtr;\n")
        f.write("  final bool memWr;\n")
        f.write("  final int resSrc;\n")
        f.write("  final int immSrc;\n")
        f.write("  final int mask;\n")
        f.write("  final int value;\n")
        f.write("  final String type;\n")
        f.write("  final int cycles;\n\n")
        f.write("  final int controlWord;\n\n")

        # Empty constructor with default 'nop' values
        f.write("  const InstructionInfo() :\n")
        f.write(f'    instr = "{nop_instr_data["instr"]}",\n')
        f.write(f'    pcSrc = {nop_instr_data["PCsrc"]},\n')
        f.write(f'    brWr = {bool_to_dart(nop_instr_data["BRwr"])},\n')
        f.write(f'    aluSrc = {nop_instr_data["ALUsrc"]},\n')
        f.write(f'    aluCtr = {nop_instr_data["ALUctr"]},\n')
        f.write(f'    memWr = {bool_to_dart(nop_instr_data["MemWr"])},\n')
        f.write(f'    resSrc = {nop_instr_data["ResSrc"]},\n')
        f.write(f'    immSrc = {nop_instr_data["ImmSrc"]},\n')
        f.write(f'    mask = 0x{nop_instr_data["mask"]:X},\n')
        f.write(f'    value = 0x{nop_instr_data["value"]:X},\n')
        f.write(f'    type = \'{nop_instr_data["type"]}\',\n')
        f.write(f'    cycles = {nop_instr_data["cycles"]},\n')
        f.write(f'    controlWord = 0x{nop_instr_data["control_word"]:04X};\n\n')

        # Private constructor for the table
        f.write("  const InstructionInfo._internal({\n")
        f.write("    required this.instr, required this.pcSrc, required this.brWr, required this.aluSrc,\n")
        f.write("    required this.aluCtr, required this.memWr, required this.resSrc, required this.immSrc,\n")
        f.write("    required this.mask, required this.value, required this.type, required this.cycles, required this.controlWord,\n")
        f.write("  });\n\n")

        # Factory to find an instruction by its 32-bit word
        f.write("  factory InstructionInfo.fromInstruction(int instruction) {\n")
        f.write("    for (final info in controlTable) {\n")
        f.write("      if ((instruction & info.mask) == info.value) {\n")
        f.write("        return info;\n")
        f.write("      }\n")
        f.write("    }\n")
        f.write("    // Return a default 'nop' if no instruction is found.\n")
        f.write("    return const InstructionInfo();\n")
        f.write("  }\n")

        f.write("}\n\n")
        f.write("const List<InstructionInfo> controlTable = [\n")
        for item in instructions:
            f.write("  const InstructionInfo._internal(\n")
            f.write(f'    instr: "{item["instr"]}",\n')
            f.write(f'    pcSrc: {item["PCsrc"]},\n')
            f.write(f'    brWr: {bool_to_dart(item["BRwr"])},\n')
            f.write(f'    aluSrc: {item["ALUsrc"]},\n')
            f.write(f'    aluCtr: {item["ALUctr"]},\n')
            f.write(f'    memWr: {bool_to_dart(item["MemWr"])},\n')
            f.write(f'    resSrc: {item["ResSrc"]},\n')
            f.write(f'    immSrc: {item["ImmSrc"]},\n')
            f.write(f'    mask: 0x{item["mask"]:X},\n')
            f.write(f'    value: 0x{item["value"]:X},\n')
            f.write(f'    type: \'{item["type"]}\',\n')
            f.write(f'    cycles: {item["cycles"]},\n')
            f.write(f'    controlWord: 0x{item["control_word"]:04X},\n')
            f.write("  ),\n")
        f.write("];\n")
    print(f"Generated Dart file: {path}")

def generate_python_file(instructions, layout, path):
    """Generates the Python file with the control table data."""
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, 'w', encoding='utf-8') as f:
        f.write("# Generated file. DO NOT EDIT.\n")
        f.write("# This file is automatically generated by the 'generate_control_table.py' script.\n")
        f.write("# Any changes made to this file will be overwritten.\n\n")

        # --- Control Word Layout ---
        f.write("CONTROL_WORD_LAYOUT = ")
        f.write(json.dumps(layout, indent=4))
        f.write("\n\n")

        f.write("CONTROL_TABLE = [\n")
        for item in instructions:
            f.write(f"    {repr(item)},\n")
        f.write("]\n")
    print(f"Generated Python file: {path}")

def main():
    """Main function to generate all source files."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.dirname(script_dir)
    json_path = os.path.join(script_dir, 'instructions.json')

    with open(json_path, 'r', encoding='utf-8') as f:
        json_data = json.load(f)
        instructions = json_data["instructions"]
        control_word_layout = json_data["control_word_layout"]

    for item in instructions:
        item['control_word'] = calculate_control_word(item, control_word_layout)

    generate_cpp_header(instructions, control_word_layout, os.path.join(project_root, 'core', 'include', 'ControlTableData.h'))
    generate_dart_file(instructions, control_word_layout, os.path.join(project_root, 'simulator_ui', 'lib', 'generated', 'control_table.g.dart'))
    generate_python_file(instructions, control_word_layout, os.path.join(project_root, 'api', 'control_table_data.py'))

    print("\nSource files generated successfully.")
    print("Please recompile your projects to apply the changes.")

if __name__ == "__main__":
    main()